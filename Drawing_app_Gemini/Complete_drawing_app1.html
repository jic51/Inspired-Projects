<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rainbow Drawing</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .gradient-text {
            background-image: linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #0000ff, #4b0082, #9400d3);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            -webkit-text-fill-color: transparent;
            text-fill-color: transparent;
            font-size: 2.5rem;
            font-weight: 700;
            text-align: center;
            padding: 1rem;
        }

        #app-container {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            background-color: #2a2a2a;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            text-align: center;
            position: relative;
        }

        #canvas-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
        }

        canvas {
            background-color: #1a1a1a;
            display: block;
            touch-action: none;
            width: 100%;
            height: 100%;
        }

        #button-bar {
            position: absolute;
            top: 1rem;
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: center;
            width: 100%;
            gap: 1rem;
            z-index: 10;
        }
        
        button {
            background-color: rgba(64, 64, 64, 0.7);
            border: none;
            padding: 0.75rem;
            border-radius: 9999px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            backdrop-filter: blur(5px);
            transition: all 0.2s ease-in-out;
        }

        button:hover {
            transform: scale(1.1);
            background-color: rgba(80, 80, 80, 0.9);
        }

        button:active {
            transform: scale(0.95);
        }

        button svg {
            width: 24px;
            height: 24px;
            fill: #e0e0e0;
        }

        #download-options-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(42, 42, 42, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 1rem;
            padding: 2rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            gap: 1rem;
            z-index: 100;
        }

        #download-options-modal h3 {
            font-size: 1.25rem;
            font-weight: 600;
            color: #fff;
            margin-bottom: 0.5rem;
        }

        .modal-button-container {
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .modal-button {
            background-color: #444;
            color: #fff;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            border: none;
            transition: all 0.2s;
        }

        .modal-button:hover {
            background-color: #555;
            transform: scale(1.05);
        }

        #statusMessage {
            position: absolute;
            bottom: 1rem;
            width: 90%;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            text-align: center;
            font-size: 0.9rem;
            z-index: 10;
        }
    </style>
</head>
<body>
    <div id="app-container">
        <h1 class="gradient-text">Rainbow Drawing</h1>
        <div id="button-bar">
            <button id="undoButton" title="Undo Last Stroke">
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M12.928 2.071c-.04-.04-.09-.06-.144-.06H5.5c-1.38 0-2.5 1.12-2.5 2.5v11.928c0 .054.024.104.064.144L6.96 18.25a.5.5 0 00.354.146h6.353c1.38 0 2.5-1.12 2.5-2.5V4.62c0-.054-.02-.104-.06-.144L12.928 2.07zM12.928 3.515L15.3 5.888v8.614c0 .552-.448 1-1 1H7.318a.5.5 0 00-.353.146L4.01 18.293a.5.5 0 00-.146.354V4.5c0-.827.673-1.5 1.5-1.5h7.391a.5.5 0 00.354-.146z" fill="currentColor"/>
                    <path d="M12.015 20.914a.5.5 0 00-.707-.008L9.043 18.914a.5.5 0 000 .707l2.262 2.262a.5.5 0 00.707-.707z" fill="currentColor"/>
                    <path d="M19.992 10.999a.5.5 0 00-.5-.5h-2c-.276 0-.5.224-.5.5s.224.5.5.5h2c.276 0 .5-.224.5-.5z" fill="currentColor"/>
                    <path d="M19.992 13.999a.5.5 0 00-.5-.5h-2c-.276 0-.5.224-.5.5s.224.5.5.5h2c.276 0 .5-.224.5-.5z" fill="currentColor"/>
                    <path d="M19.992 16.999a.5.5 0 00-.5-.5h-2c-.276 0-.5.224-.5.5s.224.5.5.5h2c.276 0 .5-.224.5-.5z" fill="currentColor"/>
                </svg>
            </button>
            <button id="sendButton" title="Send Drawing">
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2.01 21L23 12L2.01 3L2 10L17 12L2 14L2.01 21Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
            <button id="saveButton" title="Save Drawing">
                <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M14 2H6C5.46957 2 4.96086 2.21071 4.58579 2.58579C4.21071 2.96086 4 3.46957 4 4V20C4 20.5304 4.21071 21.0391 4.58579 21.4142C4.96086 21.7893 5.46957 22 6 22H18C18.5304 22 19.0391 21.7893 19.4142 21.4142C19.7893 21.0391 20 20.5304 20 20V8L14 2Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M14 2V8H20" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M12 17V11" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    <path d="M9 14L12 11L15 14" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                </svg>
            </button>
        </div>
        
        <div id="canvas-container">
            <canvas id="drawingCanvas"></canvas>
            <div id="download-options-modal" style="display: none;">
                <h3>Download Options</h3>
                <div class="modal-button-container">
                    <button class="modal-button" id="downloadStatic">Static</button>
                    <button class="modal-button" id="downloadReplay">Replay</button>
                </div>
            </div>
        </div>

        <p id="statusMessage">Start drawing your rainbow masterpiece!</p>

    </div>

    <script>
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const sendButton = document.getElementById('sendButton');
        const undoButton = document.getElementById('undoButton');
        const saveButton = document.getElementById('saveButton');
        const statusMessage = document.getElementById('statusMessage');
        const modal = document.getElementById('download-options-modal');
        const downloadStaticButton = document.getElementById('downloadStatic');
        const downloadReplayButton = document.getElementById('downloadReplay');

        // Drawing state
        let isDrawing = false;
        let hasSentDrawing = false;
        const brushWidth = 4;
        let hue = 0;
        let recordedStrokes = [];
        let lastX = 0;
        let lastY = 0;
        let isReplaying = false;
        let currentStrokeId = 0;

        // User info for signature (using dummy data since there's no auth)
        const userId = 'user-local';
        const userName = 'Local Artist';
        const userAvatar = 'https://placehold.co/40x40/ffffff/000000?text=U';

        // --- Canvas Setup ---
        function resizeCanvas() {
            const rect = canvas.parentNode.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            ctx.lineWidth = brushWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            redrawCanvas();
        }
        window.addEventListener('load', resizeCanvas);
        window.addEventListener('resize', resizeCanvas);

        // --- Rainbow Color Function ---
        function getRainbowColor() {
            hue = (hue + 1) % 360;
            return `hsl(${hue}, 100%, 50%)`;
        }

        // --- Drawing Functions ---
        function startDrawing(e) {
            e.preventDefault();
            if (e.button !== 0 && !e.touches) return;
            if (isReplaying) {
                stopReplay();
                clearCanvas();
                return;
            }
            if (hasSentDrawing) {
                clearCanvas();
                return;
            }
            isDrawing = true;
            currentStrokeId++;
            const { offsetX, offsetY } = getEventCoords(e);
            lastX = offsetX;
            lastY = offsetY;
            recordedStrokes.push({ type: 'start', x: offsetX, y: offsetY, strokeId: currentStrokeId });
        }

        function draw(e) {
            if (!isDrawing) return;
            const { offsetX, offsetY } = getEventCoords(e);
            ctx.strokeStyle = getRainbowColor();
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(offsetX, offsetY);
            ctx.stroke();
            lastX = offsetX;
            lastY = offsetY;
            recordedStrokes.push({ type: 'draw', x: offsetX, y: offsetY, color: ctx.strokeStyle, strokeId: currentStrokeId });
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            recordedStrokes.push({ type: 'end', strokeId: currentStrokeId });
        }

        function getEventCoords(e) {
            const rect = canvas.getBoundingClientRect();
            if (e.touches && e.touches.length > 0) {
                return {
                    offsetX: e.touches[0].clientX - rect.left,
                    offsetY: e.touches[0].clientY - rect.top
                };
            } else {
                return {
                    offsetX: e.clientX - rect.left,
                    offsetY: e.clientY - rect.top
                };
            }
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            recordedStrokes = [];
            hasSentDrawing = false;
            statusMessage.textContent = 'Canvas cleared! Start drawing a new masterpiece!';
        }
        
        // --- Replay and Control Functions ---
        async function replayDrawing() {
            isReplaying = true;
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let lastReplayX = 0;
            let lastReplayY = 0;

            for (const stroke of recordedStrokes) {
                if (!isReplaying) return;
                switch (stroke.type) {
                    case 'start':
                        lastReplayX = stroke.x;
                        lastReplayY = stroke.y;
                        break;
                    case 'draw':
                        ctx.strokeStyle = stroke.color;
                        ctx.beginPath();
                        ctx.moveTo(lastReplayX, lastReplayY);
                        ctx.lineTo(stroke.x, stroke.y);
                        ctx.stroke();
                        lastReplayX = stroke.x;
                        lastReplayY = stroke.y;
                        break;
                }
                await new Promise(r => setTimeout(r, 10));
            }
            if (isReplaying) {
                await new Promise(r => setTimeout(r, 500));
                replayDrawing();
            }
        }

        function stopReplay() {
            isReplaying = false;
            statusMessage.textContent = 'Replay stopped.';
        }

        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            let lastRedrawX = 0;
            let lastRedrawY = 0;

            recordedStrokes.forEach(stroke => {
                switch (stroke.type) {
                    case 'start':
                        lastRedrawX = stroke.x;
                        lastRedrawY = stroke.y;
                        break;
                    case 'draw':
                        ctx.strokeStyle = stroke.color;
                        ctx.beginPath();
                        ctx.moveTo(lastRedrawX, lastRedrawY);
                        ctx.lineTo(stroke.x, stroke.y);
                        ctx.stroke();
                        lastRedrawX = stroke.x;
                        lastRedrawY = stroke.y;
                        break;
                }
            });
        }

        // --- Download Functions ---
        function addSignatureToCanvas(canvasToDrawOn) {
            const signature = `by ${userName}`;
            const signatureY = canvasToDrawOn.height - 20;
            const signatureX = canvasToDrawOn.width - 20;
            const avatarSize = 30;
            const textWidth = canvasToDrawOn.getContext('2d').measureText(signature).width;

            canvasToDrawOn.getContext('2d').save();
            canvasToDrawOn.getContext('2d').font = '16px Inter, sans-serif';
            canvasToDrawOn.getContext('2d').fillStyle = 'rgba(255, 255, 255, 0.8)';
            canvasToDrawOn.getContext('2d').textAlign = 'right';
            canvasToDrawOn.getContext('2d').textBaseline = 'middle';
            canvasToDrawOn.getContext('2d').fillText(signature, signatureX, signatureY);

            // Placeholder for the avatar
            canvasToDrawOn.getContext('2d').restore();
        }

        function saveStaticDrawing() {
            statusMessage.textContent = 'Preparing static download...';
            const drawingCanvas = document.createElement('canvas');
            drawingCanvas.width = canvas.width;
            drawingCanvas.height = canvas.height;
            const drawingCtx = drawingCanvas.getContext('2d');
            drawingCtx.fillStyle = '#FFFFFF';
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            drawingCtx.drawImage(canvas, 0, 0);
            addSignatureToCanvas(drawingCanvas);
            const dataURL = drawingCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = 'rainbow_drawing_static.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            statusMessage.textContent = 'Static drawing saved!';
            hideDownloadModal();
        }

        async function saveReplayDrawing() {
            statusMessage.textContent = 'Preparing video download... This may take a moment.';
            hideDownloadModal();

            const drawingCanvas = document.createElement('canvas');
            drawingCanvas.width = canvas.width;
            drawingCanvas.height = canvas.height;
            const drawingCtx = drawingCanvas.getContext('2d');
            drawingCtx.fillStyle = '#FFFFFF';
            drawingCtx.fillRect(0, 0, drawingCanvas.width, drawingCanvas.height);

            const stream = drawingCanvas.captureStream();
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
            let chunks = [];

            recorder.ondataavailable = (e) => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = 'rainbow_drawing_replay.webm';
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                statusMessage.textContent = 'Video download complete!';
            };

            recorder.start();

            drawingCtx.clearRect(0, 0, drawingCanvas.width, drawingCanvas.height);
            let lastReplayX = 0;
            let lastReplayY = 0;

            for (const stroke of recordedStrokes) {
                switch (stroke.type) {
                    case 'start':
                        lastReplayX = stroke.x;
                        lastReplayY = stroke.y;
                        break;
                    case 'draw':
                        drawingCtx.strokeStyle = stroke.color;
                        drawingCtx.beginPath();
                        drawingCtx.moveTo(lastReplayX, lastReplayY);
                        drawingCtx.lineTo(stroke.x, stroke.y);
                        drawingCtx.stroke();
                        lastReplayX = stroke.x;
                        lastReplayY = stroke.y;
                        break;
                }
                addSignatureToCanvas(drawingCanvas);
                await new Promise(r => setTimeout(r, 10));
            }
            recorder.stop();
        }

        // --- Modal Functions ---
        function showDownloadModal() {
            if (recordedStrokes.length === 0) {
                statusMessage.textContent = 'Draw something to download!';
                return;
            }
            modal.style.display = 'flex';
        }

        function hideDownloadModal() {
            modal.style.display = 'none';
        }

        // --- Event Listeners and Button Handlers ---
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);

        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e); }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); }, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        undoButton.addEventListener('click', () => {
            const lastStrokeId = recordedStrokes.length > 0 ? recordedStrokes[recordedStrokes.length - 1].strokeId : 0;
            if (lastStrokeId > 0) {
                recordedStrokes = recordedStrokes.filter(stroke => stroke.strokeId !== lastStrokeId);
                redrawCanvas();
                statusMessage.textContent = 'Last stroke undone.';
            } else {
                statusMessage.textContent = 'Nothing to undo!';
            }
        });

        sendButton.addEventListener('click', () => {
            if (recordedStrokes.length === 0) {
                statusMessage.textContent = 'Draw something before sending!';
                return;
            }
            statusMessage.textContent = 'Simulating send... Replaying your art!';
            hasSentDrawing = true;
            replayDrawing();
        });
        
        saveButton.addEventListener('click', showDownloadModal);
        downloadStaticButton.addEventListener('click', saveStaticDrawing);
        downloadReplayButton.addEventListener('click', saveReplayDrawing);
    </script>
</body>
</html>

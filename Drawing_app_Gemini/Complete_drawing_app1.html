<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Drawing App</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a;
            color: #e0e0e0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }

        .container {
            display: flex;
            flex-direction: column;
            width: 100%;
            max-width: 1200px;
            height: 100vh;
            padding: 1rem;
            gap: 1rem;
        }
        
        #loadingMessage {
            text-align: center;
            font-size: 1.5rem;
            color: #bbb;
        }

        #authContainer {
            display: none;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            width: 100%;
            height: 100%;
            background-color: #2a2a2a;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        #loginForm {
            display: flex;
            flex-direction: column;
            gap: 1rem;
            padding: 2rem;
            border-radius: 1rem;
            background-color: #333;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2);
            width: 100%;
            max-width: 400px;
        }

        #loginForm h2 {
            font-size: 1.5rem;
            font-weight: 600;
            text-align: center;
            margin-bottom: 0.5rem;
        }

        #loginForm input {
            padding: 0.75rem;
            border: 1px solid #444;
            border-radius: 0.5rem;
            background-color: #444;
            color: #e0e0e0;
            outline: none;
        }

        #loginForm button {
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        #loginForm button:hover {
            opacity: 0.8;
        }

        #loginButton, #registerButton {
            background-color: #6a1b9a;
            color: #fff;
        }

        #googleButton {
            background-color: #4285F4;
            color: #fff;
        }

        #authStatusMessage {
            margin-top: 1rem;
            text-align: center;
            font-size: 0.875rem;
        }

        #appContainer {
            display: none; /* Hidden by default, shown after login */
            flex-direction: column;
            align-items: center;
            width: 100%;
            height: 100%;
            background-color: #2a2a2a;
            border-radius: 1rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            position: relative;
        }

        #canvasWrapper {
            position: relative;
            width: 100%;
            height: 100%;
            border-radius: 1rem;
            overflow: hidden;
        }

        #drawingCanvas {
            background-color: #1a1a1a;
            display: block;
            touch-action: none; /* Prevents default touch behavior */
        }

        #controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            width: 100%;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .input-group {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-wrap: nowrap;
        }

        #recipientId {
            padding: 0.5rem;
            border-radius: 0.5rem;
            border: 1px solid #444;
            background-color: #444;
            color: #e0e0e0;
            outline: none;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
        }

        .control-button {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            background-color: #6a1b9a;
            color: white;
            border: none;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .control-button:hover {
            background-color: #5a1f6a;
        }

        #statusMessage, #currentUserId {
            text-align: center;
            margin: 0.5rem;
            font-size: 0.875rem;
            color: #bbb;
        }
        
        #saveOptions {
            display: none;
            flex-direction: column;
            gap: 0.5rem;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: #333;
            padding: 1.5rem;
            border-radius: 0.75rem;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            z-index: 10;
        }

        #saveOptions h3 {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            text-align: center;
        }

        #saveOptions button {
            padding: 0.75rem;
            border-radius: 0.5rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            background-color: #6a1b9a;
            color: white;
            border: none;
        }

        #saveOptions button:hover {
            opacity: 0.8;
        }

        #receivedDrawingContainer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(26, 26, 26, 0.9);
            border-radius: 1rem;
            z-index: 5;
            padding: 1rem;
        }

        #receivedDrawingContainer canvas {
            background-color: transparent;
            border-radius: 1rem;
        }
    </style>
</head>
<body>
    <div id="loadingMessage">Connecting to server...</div>

    <div id="authContainer" class="rounded-xl p-8 shadow-lg">
        <form id="loginForm" class="bg-gray-800 p-6 rounded-lg shadow-xl">
            <h2 class="text-white text-2xl font-bold mb-4">Welcome to Creative Canvas</h2>
            <p class="text-sm text-gray-400 mb-6">Please sign in or create an account to start drawing and sharing your art.</p>
            <input type="email" id="emailInput" placeholder="Email" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-600 mb-4" required>
            <input type="password" id="passwordInput" placeholder="Password" class="w-full bg-gray-700 text-white p-3 rounded-lg border border-gray-600 focus:outline-none focus:ring-2 focus:ring-purple-600 mb-6" required>
            <div class="flex gap-4">
                <button type="submit" id="loginButton" class="flex-1 bg-purple-600 text-white p-3 rounded-lg font-bold hover:bg-purple-700 transition-colors duration-300">Log In</button>
                <button type="button" id="registerButton" class="flex-1 bg-gray-600 text-white p-3 rounded-lg font-bold hover:bg-gray-700 transition-colors duration-300">Register</button>
            </div>
            <div class="flex items-center my-4">
                <div class="flex-grow border-t border-gray-600"></div>
                <span class="mx-4 text-gray-500">or</span>
                <div class="flex-grow border-t border-gray-600"></div>
            </div>
            <button type="button" id="googleButton" class="w-full bg-blue-600 text-white p-3 rounded-lg font-bold hover:bg-blue-700 transition-colors duration-300">Sign in with Google</button>
        </form>
        <p id="authStatusMessage" class="mt-4 text-sm text-red-400"></p>
    </div>

    <div id="appContainer" class="container">
        <p id="currentUserId" class="text-center font-bold text-lg text-white rounded-lg p-2 bg-gray-800 shadow-inner">Your User ID: </p>
        <p id="statusMessage" class="text-center mt-2 text-sm text-gray-400"></p>
        <div id="canvasWrapper" class="bg-gray-800 rounded-lg shadow-xl relative overflow-hidden">
            <canvas id="drawingCanvas"></canvas>
            <div id="receivedDrawingContainer" class="hidden"></div>
        </div>
        <div id="controls" class="bg-gray-800 rounded-lg p-4 shadow-xl flex-col sm:flex-row">
            <div class="input-group">
                <input type="text" id="recipientId" placeholder="Recipient's User ID" class="flex-1 text-sm sm:text-base">
                <button id="sendButton" class="control-button">Send</button>
            </div>
            <div class="button-group mt-2 sm:mt-0">
                <button id="undoButton" class="control-button">Undo</button>
                <button id="saveButton" class="control-button">Save</button>
                <button id="signOutButton" class="control-button bg-red-600 hover:bg-red-700">Sign Out</button>
            </div>
        </div>
    </div>

    <div id="saveOptions" class="hidden">
        <h3>Download Drawing</h3>
        <button id="saveStatic" class="control-button">As Static Image (PNG)</button>
        <button id="saveReplay" class="control-button">As Replayable Video (WEBM)</button>
    </div>

    <script type="module">
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const sendButton = document.getElementById('sendButton');
        const undoButton = document.getElementById('undoButton');
        const saveButton = document.getElementById('saveButton');
        const saveOptions = document.getElementById('saveOptions');
        const saveStaticButton = document.getElementById('saveStatic');
        const saveReplayButton = document.getElementById('saveReplay');
        const statusMessage = document.getElementById('statusMessage');
        const receivedDrawingContainer = document.getElementById('receivedDrawingContainer');
        const recipientIdInput = document.getElementById('recipientId');
        const currentUserIdDisplay = document.getElementById('currentUserId');
        const authContainer = document.getElementById('authContainer');
        const loginForm = document.getElementById('loginForm');
        const emailInput = document.getElementById('emailInput');
        const passwordInput = document.getElementById('passwordInput');
        const loginButton = document.getElementById('loginButton');
        const registerButton = document.getElementById('registerButton');
        const googleButton = document.getElementById('googleButton');
        const signOutButton = document.getElementById('signOutButton');
        const appContainer = document.getElementById('appContainer');
        const authStatusMessage = document.getElementById('authStatusMessage');
        const loadingMessage = document.getElementById('loadingMessage');
        
        // Drawing state
        let isDrawing = false;
        let hasSentDrawing = false;
        const brushWidth = 4;
        let hue = 0;
        let recordedStrokes = [];
        let lastTimestamp = 0;
        let currentStrokeId = 0;
        
        let lastX = 0;
        let lastY = 0;
        
        // Replay state
        let isReplaying = false;
        let replayTimeout;
        
        // Placeholder for user data
        const userData = {
            name: 'Creative Canvas User',
            profilePicUrl: 'https://placehold.co/40x40/5a1f6a/FFFFFF?text=P'
        };
        
        // --- Firebase Setup ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, GoogleAuthProvider, signInWithPopup, signOut } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, getDocs, query, where, Timestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        // Enable debug logging for Firestore
        setLogLevel('Debug');
        
        let userId = null;
        
        // Authenticate user and listen for changes
        // This listener fires once on app load and whenever the auth state changes
        onAuthStateChanged(auth, async (user) => {
            // Hide the loading message once the auth state is determined
            loadingMessage.style.display = 'none';

            if (user) {
                // User is signed in.
                userId = user.uid;
                currentUserIdDisplay.textContent = `Your User ID: ${userId}`;
                console.log(`User authenticated with ID: ${userId}`);
        
                // Show the main app and hide the auth form
                authContainer.style.display = 'none';
                appContainer.style.display = 'flex';
        
                // Set up real-time listener for incoming messages
                const messagesRef = collection(db, `artifacts/${appId}/public/data/messages`);
                const q = query(messagesRef, where("recipientId", "==", userId));
                onSnapshot(q, (snapshot) => {
                    snapshot.docChanges().forEach((change) => {
                        if (change.type === "added") {
                            console.log("New message received:", change.doc.data());
                            displayReceivedDrawing(change.doc.data());
                        }
                    });
                });
            } else {
                // No user is signed in. Attempt to sign in with the custom token.
                if (initialAuthToken) {
                    try {
                        await signInWithCustomToken(auth, initialAuthToken);
                    } catch (error) {
                        console.error("Firebase custom token auth error:", error);
                        // If token sign-in fails, show the regular auth form
                        authContainer.style.display = 'flex';
                        appContainer.style.display = 'none';
                    }
                } else {
                    // Fallback to anonymous sign-in if no token is available
                    try {
                        await signInAnonymously(auth);
                    } catch (error) {
                        console.error("Firebase anonymous auth error:", error);
                        // If all sign-in methods fail, show the regular auth form
                        authContainer.style.display = 'flex';
                        appContainer.style.display = 'none';
                    }
                }
                userId = null;
                currentUserIdDisplay.textContent = '';
            }
        });
        
        // --- Authentication Handlers ---
        loginButton.addEventListener('click', async (e) => {
            e.preventDefault();
            const email = emailInput.value;
            const password = passwordInput.value;
            try {
                await signInWithEmailAndPassword(auth, email, password);
                authStatusMessage.textContent = "Logged in successfully!";
            } catch (error) {
                authStatusMessage.textContent = `Login failed: ${error.message}`;
            }
        });
        
        registerButton.addEventListener('click', async (e) => {
            e.preventDefault();
            const email = emailInput.value;
            const password = passwordInput.value;
            try {
                await createUserWithEmailAndPassword(auth, email, password);
                authStatusMessage.textContent = "Registered and logged in successfully!";
            } catch (error) {
                authStatusMessage.textContent = `Registration failed: ${error.message}`;
            }
        });
        
        googleButton.addEventListener('click', async (e) => {
            e.preventDefault();
            const provider = new GoogleAuthProvider();
            try {
                await signInWithPopup(auth, provider);
                authStatusMessage.textContent = "Signed in with Google!";
            } catch (error) {
                authStatusMessage.textContent = `Google sign-in failed: ${error.message}`;
            }
        });
        
        signOutButton.addEventListener('click', async () => {
            try {
                await signOut(auth);
                clearCanvas();
                authStatusMessage.textContent = "Signed out successfully.";
            } catch (error) {
                authStatusMessage.textContent = `Sign out failed: ${error.message}`;
            }
        });
        
        
        // --- Canvas Setup ---
        function resizeCanvas() {
            const rect = canvas.parentNode.getBoundingClientRect();
            canvas.width = rect.width;
            canvas.height = rect.height;
            ctx.lineWidth = brushWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            if (recordedStrokes.length > 0) {
                redrawCanvas();
            }
        }
        window.addEventListener('load', () => {
            resizeCanvas();
            loadingMessage.style.display = 'block';
        });
        window.addEventListener('resize', resizeCanvas);
        
        ctx.lineWidth = brushWidth;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        
        // --- Rainbow Color Function ---
        function getRainbowColor() {
            hue = (hue + 1) % 360;
            return `hsl(${hue}, 100%, 50%)`;
        }
        
        // --- Drawing Functions ---
        function startDrawing(e) {
            e.preventDefault();
        
            if (e.button !== 0 && !e.touches) {
                return;
            }
        
            if (isReplaying) {
                // Stop replay and clear canvas with a single click
                stopReplay();
                clearCanvas();
                return;
            }
        
            if (hasSentDrawing) {
                // This case is now handled by the isReplaying block
                return;
            }
        
            isDrawing = true;
            currentStrokeId++;
            const { offsetX, offsetY } = getEventCoords(e);
        
            lastX = offsetX;
            lastY = offsetY;
        
            lastTimestamp = performance.now();
            recordedStrokes.push({
                type: 'start',
                x: offsetX,
                y: offsetY,
                timestampOffset: 0,
                strokeId: currentStrokeId
            });
        }
        
        function draw(e) {
            if (!isDrawing) return;
            const { offsetX, offsetY } = getEventCoords(e);
        
            ctx.strokeStyle = getRainbowColor();
        
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(offsetX, offsetY);
            ctx.stroke();
        
            lastX = offsetX;
            lastY = offsetY;
        
            const currentTimestamp = performance.now();
            recordedStrokes.push({
                type: 'draw',
                x: offsetX,
                y: offsetY,
                color: ctx.strokeStyle,
                timestampOffset: currentTimestamp - lastTimestamp,
                strokeId: currentStrokeId
            });
            lastTimestamp = currentTimestamp;
        }
        
        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            recordedStrokes.push({ type: 'end', timestampOffset: 0, strokeId: currentStrokeId });
        }
        
        // --- New and more reliable coordinate function ---
        function getEventCoords(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                offsetX: clientX - rect.left,
                offsetY: clientY - rect.top
            };
        }
        
        // --- Replay and Control Functions ---
        
        function stopReplay() {
            isReplaying = false;
            clearTimeout(replayTimeout);
            statusMessage.textContent = 'Replay stopped. Draw a new masterpiece!';
            sendButton.disabled = false;
        }
        
        async function replayDrawing(drawingData) {
            isReplaying = true;
        
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        
            let lastReplayX = 0;
            let lastReplayY = 0;
        
            for (let i = 0; i < drawingData.strokes.length && isReplaying; i++) {
                const stroke = drawingData.strokes[i];
        
                if (stroke.timestampOffset > 0) {
                    await new Promise(resolve => setTimeout(resolve, stroke.timestampOffset));
                }
        
                if (!isReplaying) {
                    return;
                }
        
                switch (stroke.type) {
                    case 'start':
                        lastReplayX = stroke.x;
                        lastReplayY = stroke.y;
                        break;
                    case 'draw':
                        ctx.strokeStyle = stroke.color;
                        ctx.beginPath();
                        ctx.moveTo(lastReplayX, lastReplayY);
                        ctx.lineTo(stroke.x, stroke.y);
                        ctx.stroke();
                        lastReplayX = stroke.x;
                        lastReplayY = stroke.y;
                        break;
                    case 'end':
                        break;
                }
            }
        
            if (isReplaying) {
                replayTimeout = setTimeout(() => {
                    replayDrawing(drawingData);
                }, 500);
            }
        }
        
        // Undo function
        function undoStroke() {
            if (isReplaying || recordedStrokes.length === 0) return;
        
            const lastStrokeId = recordedStrokes[recordedStrokes.length - 1].strokeId;
            recordedStrokes = recordedStrokes.filter(stroke => stroke.strokeId !== lastStrokeId);
        
            redrawCanvas();
            statusMessage.textContent = 'Last stroke undone.';
        }
        
        // Save function (updated to show options)
        function saveDrawing() {
            if (recordedStrokes.length === 0) {
                statusMessage.textContent = 'Draw something to save!';
                return;
            }
            statusMessage.textContent = 'Choose a download option:';
            saveOptions.style.display = 'flex';
        }
        
        // New save functions for static and replay versions
        async function saveStaticDrawing() {
            // Clear the canvas and redraw everything with a white background for a clean download
            ctx.fillStyle = '#FFFFFF';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            redrawCanvas();
        
            const originalImage = canvas.toDataURL('image/png');
            const finalImage = await addCreatorInfo(originalImage, '#000000', '#FFFFFF'); // Black text on white background
            downloadImage(finalImage, 'rainbow_drawing_static.png');
            statusMessage.textContent = 'Static drawing saved!';
            hideSaveOptions();
            // Redraw the canvas with the original dark background
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            redrawCanvas();
        }
        
        async function saveReplayDrawing() {
            statusMessage.textContent = 'Generating video... this may take a moment.';
            hideSaveOptions();
            
            // Create a temporary, off-screen canvas for a clean recording
            const recordingCanvas = document.createElement('canvas');
            recordingCanvas.width = canvas.width;
            recordingCanvas.height = canvas.height;
            const recordingCtx = recordingCanvas.getContext('2d');
            
            const stream = recordingCanvas.captureStream(60); // 60 FPS
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
            const videoChunks = [];
        
            recorder.ondataavailable = (e) => videoChunks.push(e.data);
            recorder.onstop = () => {
                const videoBlob = new Blob(videoChunks, { type: 'video/webm' });
                const videoUrl = URL.createObjectURL(videoBlob);
                downloadImage(videoUrl, 'rainbow_drawing_replay.webm');
                statusMessage.textContent = 'Replay video saved!';
                URL.revokeObjectURL(videoUrl);
            };
        
            recorder.start();
            await recordDrawing(recordingCtx);
            recorder.stop();
        }
        
        async function recordDrawing(context) {
            // Clear the recording canvas and set up initial state for a clean video
            context.clearRect(0, 0, canvas.width, canvas.height);
            let lastX_record = 0;
            let lastY_record = 0;
            
            // Draw signature
            drawSignatureOnCanvas(context, '#e0e0e0', '#1a1a1a');
        
            for (let i = 0; i < recordedStrokes.length; i++) {
                const stroke = recordedStrokes[i];
                
                if (stroke.timestampOffset > 0) {
                    await new Promise(resolve => setTimeout(resolve, stroke.timestampOffset));
                }
        
                switch (stroke.type) {
                    case 'start':
                        lastX_record = stroke.x;
                        lastY_record = stroke.y;
                        break;
                    case 'draw':
                        context.strokeStyle = stroke.color;
                        context.beginPath();
                        context.moveTo(lastX_record, lastY_record);
                        context.lineTo(stroke.x, stroke.y);
                        context.stroke();
                        lastX_record = stroke.x;
                        lastY_record = stroke.y;
                        break;
                }
            }
        }
        
        function hideSaveOptions() {
            saveOptions.style.display = 'none';
        }
        
        function downloadImage(dataUrl, filename) {
            const a = document.createElement('a');
            a.href = dataUrl;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        // Function to draw the creator's info on a given context
        function drawSignatureOnCanvas(context, textColor, bgColor) {
            const text = `Created by ${userData.name}`;
            const profilePicSize = 24;
            const padding = 10;
            
            // Measure text to determine background box size
            context.font = '20px Arial';
            const textWidth = context.measureText(text).width;
            const totalWidth = textWidth + profilePicSize + 15;
            const totalHeight = 35; // A fixed height for the signature box
        
            // Calculate position
            const boxX = canvas.width - totalWidth - padding;
            const boxY = canvas.height - totalHeight - padding;
        
            // Draw a semi-transparent box behind the text
            context.fillStyle = 'rgba(26, 26, 26, 0.5)'; // A universal color that works on both white and black backgrounds
            context.fillRect(boxX, boxY, totalWidth, totalHeight);
        
            // Draw the profile picture placeholder
            context.fillStyle = userData.profilePicUrl.includes('placeholder') ? '#6a1b9a' : bgColor;
            context.beginPath();
            context.arc(boxX + profilePicSize / 2 + 5, boxY + profilePicSize / 2 + 5, profilePicSize / 2, 0, Math.PI * 2);
            context.fill();
        
            // Draw the text
            context.fillStyle = textColor;
            context.fillText(text, boxX + profilePicSize + 10, boxY + 25);
        }
        
        
        // Function to add creator's info to the image
        async function addCreatorInfo(imageDataUrl, textColor, bgColor) {
            const finalCanvas = document.createElement('canvas');
            const finalCtx = finalCanvas.getContext('2d');
            const image = new Image();
        
            return new Promise(resolve => {
                image.onload = () => {
                    finalCanvas.width = image.width;
                    finalCanvas.height = image.height;
                    finalCtx.fillStyle = bgColor;
                    finalCtx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
                    finalCtx.drawImage(image, 0, 0);
        
                    drawSignatureOnCanvas(finalCtx, textColor, bgColor);
        
                    resolve(finalCanvas.toDataURL('image/png'));
                };
                image.src = imageDataUrl;
            });
        }
        
        // Redraw all recorded strokes
        function redrawCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        
            let lastRedrawX = 0;
            let lastRedrawY = 0;
        
            ctx.lineWidth = brushWidth;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        
            recordedStrokes.forEach(stroke => {
                switch (stroke.type) {
                    case 'start':
                        lastRedrawX = stroke.x;
                        lastRedrawY = stroke.y;
                        break;
                    case 'draw':
                        ctx.strokeStyle = stroke.color;
                        ctx.beginPath();
                        ctx.moveTo(lastRedrawX, lastRedrawY);
                        ctx.lineTo(stroke.x, stroke.y);
                        ctx.stroke();
                        lastRedrawX = stroke.x;
                        lastRedrawY = stroke.y;
                        break;
                    case 'end':
                        break;
                }
            });
        }
        
        // Clear canvas function
        function clearCanvas() {
            stopReplay();
            recordedStrokes = [];
            hasSentDrawing = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            statusMessage.textContent = 'Canvas cleared! Start drawing a new masterpiece!';
        }
        
        // --- Event Listeners and Button Handlers ---
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); startDrawing(e); }, { passive: false });
        canvas.addEventListener('touchmove', (e) => { e.preventDefault(); draw(e); }, { passive: false });
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);
        
        canvas.addEventListener('contextmenu', (e) => e.preventDefault());
        
        undoButton.addEventListener('click', undoStroke);
        saveButton.addEventListener('click', saveDrawing);
        saveStaticButton.addEventListener('click', saveStaticDrawing);
        saveReplayButton.addEventListener('click', saveReplayDrawing);
        
        sendButton.addEventListener('click', async () => {
            if (recordedStrokes.length === 0) {
                statusMessage.textContent = 'Draw something before sending!';
                return;
            }
            const recipientId = recipientIdInput.value.trim();
            if (!recipientId) {
                statusMessage.textContent = 'Please enter a recipient User ID!';
                return;
            }
        
            statusMessage.textContent = 'Sending drawing...';
            sendButton.disabled = true;
            
            const drawingData = {
                senderId: userId,
                recipientId: recipientId,
                strokes: JSON.stringify(recordedStrokes), // Store as a JSON string
                timestamp: Timestamp.now()
            };
        
            try {
                const messagesRef = collection(db, `artifacts/${appId}/public/data/messages`);
                await addDoc(messagesRef, drawingData);
                statusMessage.textContent = 'Drawing sent successfully!';
                sendButton.disabled = false;
            } catch (e) {
                console.error("Error sending drawing:", e);
                statusMessage.textContent = 'Failed to send drawing. Please try again.';
                sendButton.disabled = false;
            }
        });
        
        
        // --- Display and Manage Received Drawings (No changes here) ---
        function displayReceivedDrawing(drawingData) {
            stopReplay();
        
            receivedDrawingContainer.innerHTML = '';
        
            const receivedCanvas = document.createElement('canvas');
            receivedCanvas.id = 'receivedDrawingCanvas';
            receivedCanvas.width = canvas.width;
            receivedCanvas.height = canvas.height;
            receivedDrawingContainer.appendChild(receivedCanvas);
        
            const receivedMessage = document.createElement('p');
            receivedMessage.textContent = `New drawing received from ${drawingData.senderId}!`;
            receivedDrawingContainer.appendChild(receivedMessage);
        
            let lastReplayX = 0;
            let lastReplayY = 0;
        
            const strokes = JSON.parse(drawingData.strokes);
        
            async function replayForRecipient() {
              for (let i = 0; i < strokes.length; i++) {
                const stroke = strokes[i];
        
                if (stroke.timestampOffset > 0) {
                    await new Promise(resolve => setTimeout(resolve, stroke.timestampOffset));
                }
        
                switch (stroke.type) {
                    case 'start':
                        lastReplayX = stroke.x;
                        lastReplayY = stroke.y;
                        break;
                    case 'draw':
                        receivedCanvas.getContext('2d').strokeStyle = stroke.color;
                        receivedCanvas.getContext('2d').beginPath();
                        receivedCanvas.getContext('2d').moveTo(lastReplayX, lastReplayY);
                        receivedCanvas.getContext('2d').lineTo(stroke.x, stroke.y);
                        receivedCanvas.getContext('2d').stroke();
                        lastReplayX = stroke.x;
                        lastReplayY = stroke.y;
                        break;
                    case 'end':
                        break;
                }
              }
            }
        
            replayForRecipient();
        }
        
        // Initial status message
        statusMessage.textContent = 'Start drawing your rainbow masterpiece!';
    </script>
</body>
</html>
